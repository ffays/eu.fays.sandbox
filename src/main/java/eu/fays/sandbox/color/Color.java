package eu.fays.sandbox.color;

/**
 * W3C Colors
 */
public enum Color {
	/** Aliceblue */
	ALICEBLUE(0xF0F8FF),
	/** Antiquewhite */
	ANTIQUEWHITE(0xFAEBD7),
	/** Aqua */
	AQUA(0x00FFFF),
	/** Aquamarine */
	AQUAMARINE(0x7FFFD4),
	/** Azure */
	AZURE(0xF0FFFF),
	/** Beige */
	BEIGE(0xF5F5DC),
	/** Bisque */
	BISQUE(0xFFE4C4),
	/** Black */
	BLACK(0x000000),
	/** Blanchedalmond */
	BLANCHEDALMOND(0xFFEBCD),
	/** Blue */
	BLUE(0x0000FF),
	/** Blueviolet */
	BLUEVIOLET(0x8A2BE2),
	/** Brown */
	BROWN(0xA52A2A),
	/** Burlywood */
	BURLYWOOD(0xDEB887),
	/** Cadetblue */
	CADETBLUE(0x5F9EA0),
	/** Chartreuse */
	CHARTREUSE(0x7FFF00),
	/** Chocolate */
	CHOCOLATE(0xD2691E),
	/** Coral */
	CORAL(0xFF7F50),
	/** Cornflowerblue */
	CORNFLOWERBLUE(0x6495ED),
	/** Cornsilk */
	CORNSILK(0xFFF8DC),
	/** Crimson */
	CRIMSON(0xDC143C),
	/** Cyan */
	CYAN(0x00FFFF),
	/** Darkblue */
	DARKBLUE(0x00008B),
	/** Darkcyan */
	DARKCYAN(0x008B8B),
	/** Darkgoldenrod */
	DARKGOLDENROD(0xB8860B),
	/** Darkgray */
	DARKGRAY(0xA9A9A9),
	/** Darkgreen */
	DARKGREEN(0x006400),
	/** Darkgrey */
	DARKGREY(0xA9A9A9),
	/** Darkkhaki */
	DARKKHAKI(0xBDB76B),
	/** Darkmagenta */
	DARKMAGENTA(0x8B008B),
	/** Darkolivegreen */
	DARKOLIVEGREEN(0x556B2F),
	/** Darkorange */
	DARKORANGE(0xFF8C00),
	/** Darkorchid */
	DARKORCHID(0x9932CC),
	/** Darkred */
	DARKRED(0x8B0000),
	/** Darksalmon */
	DARKSALMON(0xE9967A),
	/** Darkseagreen */
	DARKSEAGREEN(0x8FBC8F),
	/** Darkslateblue */
	DARKSLATEBLUE(0x483D8B),
	/** Darkslategray */
	DARKSLATEGRAY(0x2F4F4F),
	/** Darkslategrey */
	DARKSLATEGREY(0x2F4F4F),
	/** Darkturquoise */
	DARKTURQUOISE(0x00CED1),
	/** Darkviolet */
	DARKVIOLET(0x9400D3),
	/** Deeppink */
	DEEPPINK(0xFF1493),
	/** Deepskyblue */
	DEEPSKYBLUE(0x00BFFF),
	/** Dimgray */
	DIMGRAY(0x696969),
	/** Dimgrey */
	DIMGREY(0x696969),
	/** Dodgerblue */
	DODGERBLUE(0x1E90FF),
	/** Firebrick */
	FIREBRICK(0xB22222),
	/** Floralwhite */
	FLORALWHITE(0xFFFAF0),
	/** Forestgreen */
	FORESTGREEN(0x228B22),
	/** Fuchsia */
	FUCHSIA(0xFF00FF),
	/** Gainsboro */
	GAINSBORO(0xDCDCDC),
	/** Ghostwhite */
	GHOSTWHITE(0xF8F8FF),
	/** Gold */
	GOLD(0xFFD700),
	/** Goldenrod */
	GOLDENROD(0xDAA520),
	/** Gray */
	GRAY(0x808080),
	/** Green */
	GREEN(0x008000),
	/** Greenyellow */
	GREENYELLOW(0xADFF2F),
	/** Grey */
	GREY(0x808080),
	/** Honeydew */
	HONEYDEW(0xF0FFF0),
	/** Hotpink */
	HOTPINK(0xFF69B4),
	/** Indianred */
	INDIANRED(0xCD5C5C),
	/** Indigo */
	INDIGO(0x4B0082),
	/** Ivory */
	IVORY(0xFFFFF0),
	/** Khaki */
	KHAKI(0xF0E68C),
	/** Lavender */
	LAVENDER(0xE6E6FA),
	/** Lavenderblush */
	LAVENDERBLUSH(0xFFF0F5),
	/** Lawngreen */
	LAWNGREEN(0x7CFC00),
	/** Lemonchiffon */
	LEMONCHIFFON(0xFFFACD),
	/** Lightblue */
	LIGHTBLUE(0xADD8E6),
	/** Lightcoral */
	LIGHTCORAL(0xF08080),
	/** Lightcyan */
	LIGHTCYAN(0xE0FFFF),
	/** Lightgoldenrodyellow */
	LIGHTGOLDENRODYELLOW(0xFAFAD2),
	/** Lightgray */
	LIGHTGRAY(0xD3D3D3),
	/** Lightgreen */
	LIGHTGREEN(0x90EE90),
	/** Lightgrey */
	LIGHTGREY(0xD3D3D3),
	/** Lightpink */
	LIGHTPINK(0xFFB6C1),
	/** Lightsalmon */
	LIGHTSALMON(0xFFA07A),
	/** Lightseagreen */
	LIGHTSEAGREEN(0x20B2AA),
	/** Lightskyblue */
	LIGHTSKYBLUE(0x87CEFA),
	/** Lightslategray */
	LIGHTSLATEGRAY(0x778899),
	/** Lightslategrey */
	LIGHTSLATEGREY(0x778899),
	/** Lightsteelblue */
	LIGHTSTEELBLUE(0xB0C4DE),
	/** Lightyellow */
	LIGHTYELLOW(0xFFFFE0),
	/** Lime */
	LIME(0x00FF00),
	/** Limegreen */
	LIMEGREEN(0x32CD32),
	/** Linen */
	LINEN(0xFAF0E6),
	/** Magenta */
	MAGENTA(0xFF00FF),
	/** Maroon */
	MAROON(0x800000),
	/** Mediumaquamarine */
	MEDIUMAQUAMARINE(0x66CDAA),
	/** Mediumblue */
	MEDIUMBLUE(0x0000CD),
	/** Mediumorchid */
	MEDIUMORCHID(0xBA55D3),
	/** Mediumpurple */
	MEDIUMPURPLE(0x9370DB),
	/** Mediumseagreen */
	MEDIUMSEAGREEN(0x3CB371),
	/** Mediumslateblue */
	MEDIUMSLATEBLUE(0x7B68EE),
	/** Mediumspringgreen */
	MEDIUMSPRINGGREEN(0x00FA9A),
	/** Mediumturquoise */
	MEDIUMTURQUOISE(0x48D1CC),
	/** Mediumvioletred */
	MEDIUMVIOLETRED(0xC71585),
	/** Midnightblue */
	MIDNIGHTBLUE(0x191970),
	/** Mintcream */
	MINTCREAM(0xF5FFFA),
	/** Mistyrose */
	MISTYROSE(0xFFE4E1),
	/** Moccasin */
	MOCCASIN(0xFFE4B5),
	/** Navajowhite */
	NAVAJOWHITE(0xFFDEAD),
	/** Navy */
	NAVY(0x000080),
	/** Oldlace */
	OLDLACE(0xFDF5E6),
	/** Olive */
	OLIVE(0x808000),
	/** Olivedrab */
	OLIVEDRAB(0x6B8E23),
	/** Orange */
	ORANGE(0xFFA500),
	/** Orangered */
	ORANGERED(0xFF4500),
	/** Orchid */
	ORCHID(0xDA70D6),
	/** Palegoldenrod */
	PALEGOLDENROD(0xEEE8AA),
	/** Palegreen */
	PALEGREEN(0x98FB98),
	/** Paleturquoise */
	PALETURQUOISE(0xAFEEEE),
	/** Palevioletred */
	PALEVIOLETRED(0xDB7093),
	/** Papayawhip */
	PAPAYAWHIP(0xFFEFD5),
	/** Peachpuff */
	PEACHPUFF(0xFFDAB9),
	/** Peru */
	PERU(0xCD853F),
	/** Pink */
	PINK(0xFFC0CB),
	/** Plum */
	PLUM(0xDDA0DD),
	/** Powderblue */
	POWDERBLUE(0xB0E0E6),
	/** Purple */
	PURPLE(0x800080),
	/** Red */
	RED(0xFF0000),
	/** Rosybrown */
	ROSYBROWN(0xBC8F8F),
	/** Royalblue */
	ROYALBLUE(0x4169E1),
	/** Saddlebrown */
	SADDLEBROWN(0x8B4513),
	/** Salmon */
	SALMON(0xFA8072),
	/** Sandybrown */
	SANDYBROWN(0xF4A460),
	/** Seagreen */
	SEAGREEN(0x2E8B57),
	/** Seashell */
	SEASHELL(0xFFF5EE),
	/** Sienna */
	SIENNA(0xA0522D),
	/** Silver */
	SILVER(0xC0C0C0),
	/** Skyblue */
	SKYBLUE(0x87CEEB),
	/** Slateblue */
	SLATEBLUE(0x6A5ACD),
	/** Slategray */
	SLATEGRAY(0x708090),
	/** Slategrey */
	SLATEGREY(0x708090),
	/** Snow */
	SNOW(0xFFFAFA),
	/** Springgreen */
	SPRINGGREEN(0x00FF7F),
	/** Steelblue */
	STEELBLUE(0x4682B4),
	/** Tan */
	TAN(0xD2B48C),
	/** Teal */
	TEAL(0x008080),
	/** Thistle */
	THISTLE(0xD8BFD8),
	/** Tomato */
	TOMATO(0xFF6347),
	/** Turquoise */
	TURQUOISE(0x40E0D0),
	/** Violet */
	VIOLET(0xEE82EE),
	/** Wheat */
	WHEAT(0xF5DEB3),
	/** White */
	WHITE(0xFFFFFF),
	/** Whitesmoke */
	WHITESMOKE(0xF5F5F5),
	/** Yellow */
	YELLOW(0xFFFF00),
	/** Yellowgreen */
	YELLOWGREEN(0x9ACD32);

	public final int rgb;

	/**
	 * Constructor
	 * @param value RGB input
	 */
	private Color(final int rgb) {
		this.rgb = rgb;
	}
	
	/**
	 * Returns the red component
	 * @return the red component
	 */
	public int getRed() {
		return (rgb >> 16) & 0xFF;
	}

	/**
	 * Returns the green component
	 * @return the green component
	 */
	public int getGreen() {
		return (rgb >> 8) & 0xFF;
	}

	/**
	 * Returns the blue component
	 * @return the blue component
	 */
	public int getBlue() {
		return rgb & 0xFF;
	}
	
	/**
	 * Returns red (bits 16..23), green (bits 8..15) and blue (bits 0..7) components as an unique integer
	 * @return red, green and blue components as an unique integer
	 */
	public int getRGB() {
		return rgb;
	}

	/**
	 * Returns hue (bits 16..23), saturation (bits 8..15) and value (bits 0..7) as an unique integer
	 * @return hue, saturation and value as an unique integer
	 */
	public int getHSV() {
		return hsv(getHueSaturationValueEightBits());
	}

	/**
	 * Returns red, green and blue components
	 * @return red, green and blue components
	 */
	public int[] getRedGreenBlue() {
		return rgb(rgb);
	}

	/**
	 * Returns the hue (8 bits), saturation (8 bits) and value (8 bits)
	 * @return the hue (8 bits), saturation (8 bits) and value (8 bits)
	 */
	public int[] getHueSaturationValueEightBits() {
		return hsv(getHueSaturationValue());		
	}

	/**
	 * Returns the hue (degrees), saturation (ratio between 0 and 1) and value (ratio between 0 and 1)
	 * @return the hue (degrees), saturation (ratio between 0 and 1) and value (ratio between 0 and 1)
	 */
	public float[] getHueSaturationValue() {
		return rgb2hsv(rgb(rgb));
	}
	
	/**
	 * Returns the hue in degrees
	 * @return the hue in degrees 
	 */
	public float getHue() {
		return getHueSaturationValue()[0];
	}
	
	/**
	 * Returns the saturation [0..1] 
	 * @return the saturation [0..1] 
	 */
	public float getSaturation() {
		return getHueSaturationValue()[1];
	}
	
	/**
	 * Returns the value [0..1] 
	 * @return the value [0..1]
	 */
	public float getValue() {
		return getHueSaturationValue()[2];
	}

	/**
	 * Find the closest color by RGB distance
	 * @param rgb red (bits 16..23), green (bits 8..15) and blue (bits 0..7) components as an unique integer
	 * @return the closest color
	 */
	public static Color findClosestColorByRedGreenBlueDistance(final int rgb) {
		final int[] redGreenBlue = rgb(rgb);
		double shortest = Double.MAX_VALUE;
		Color result = BLACK;
		for(final Color color : values()) {
			if(color.rgb == rgb) {
				// Exact match
				return color;
			}
		
			final double distance = distance(color.getRedGreenBlue(), redGreenBlue);
			if(distance < shortest) {
				shortest = distance;
				result = color;
			}
		}

		return result;
	}

	/**
	 * Find the closest color by HSV distance
	 * @param rgb red (bits 16..23), green (bits 8..15) and blue (bits 0..7) components as an unique integer
	 * @return the closest color
	 */
	public static Color findClosestColorByHueSaturationValueDistance(final int rgb) {
		final int[] hueSaturationValue0 = hsv(rgb2hsv(rgb(rgb)));
		final int hsv = hsv(hueSaturationValue0);
		
		double shortest = Double.MAX_VALUE;
		Color result = BLACK;
		for(final Color color : values()) {
			final int[] hueSaturationValue1 = color.getHueSaturationValueEightBits();
			if(hsv(hueSaturationValue1) == hsv) {
				// Exact match
				return color;
			}
		
			final double distance = distance(hueSaturationValue0, hueSaturationValue1);
			if(distance < shortest) {
				shortest = distance;
				result = color;
			}
		}

		return result;
	}

	/**
	 * Computes the distance between two 3-dimension points
	 * @param a first point coordinates
	 * @param b second point coordinates
	 * @return the distance
	 */
	private static double distance(int[] a, int [] b) {
		final int deltaSquarasSum = ((a[0] - b[0])*(a[0] - b[0]))+((a[1] - b[1])*(a[1] - b[1]))+((a[2] - b[2])*(a[2] - b[2])); 
		final double result = Math.sqrt((double)deltaSquarasSum);
		return result;
	}
	
	/**
	 * Returns red, green and blue components
	 * @param rgb red, green and blue components as an unique integer
	 * @return red, green and blue components
	 */
	private static int[] rgb(final int rgb) {
		return new int [] { (rgb >> 16) & 0xFF, (rgb >> 8) & 0xFF, rgb & 0xFF } ; 		
	}
	
	/**
	 * Returns the hue (8 bits), saturation (8 bits) and value (8 bits)
	 * @param hueSaturationValue hue (degrees), saturation (ratio between 0 and 1) and value (ratio between 0 and 1)
	 * @return the hue (8 bits), saturation (8 bits) and value (8 bits)
	 */
	private static int[] hsv(final float[] hueSaturationValue) {
		return new int [] { (int)(hueSaturationValue[0] * 255F / 360F), (int)(hueSaturationValue[1] * 255F), (int)(hueSaturationValue[2] * 255F) };
	}
	
	/**
	 * Returns hue (bits 16..23), saturation (bits 8..15) and value (bits 0..7) as an unique integer
	 * @param hueSaturationValue hue (8 bits), saturation (8 bits) and value (8 bits)
	 * @return hue, saturation and value as an unique integer
	 */
	private static final int hsv(final int [] hueSaturationValue) {
		return (hueSaturationValue[0] << 16) | (hueSaturationValue[1] << 8) | hueSaturationValue[2];
	}

	/**
	 * Returns the hue (degrees), saturation (ratio between 0 and 1) and value (ratio between 0 and 1)
	 * @param redGreenBlue red, green and blue components
	 * @return the hue (degrees), saturation (ratio between 0 and 1) and value (ratio between 0 and 1)
	 */
	private static float[] rgb2hsv(final int[] redGreenBlue) {
		final int red = redGreenBlue[0];
		final int green = redGreenBlue[1];
		final int blue = redGreenBlue[2];
		final float r = ((float) red) / 255F;
		final float g = ((float) green) / 255F;
		final float b = ((float) blue) / 255F;
		
		final int max;
		if(red >= green) {
			if(red >= blue) {
				max = red;
			} else {
				max = blue;
			}
		} else if (green >= blue) {
			max = green;
		} else {
			max = blue;
		}
	
		final int min;
		if(red <= green) {
			if(red <= blue) {
				min = red;
			} else {
				min = blue;
			}
		} else if (green <= blue) {
			min = green;
		} else {
			min = blue;
		}
	
		final int delta = max - min;
		final float d = ((float)delta)/255F;
		
		float hue;
		if(delta == 0) {
			hue = 0F;
		} else if (max == red) {
			hue = 60F * ((g - b) / d);
		} else if (max == green) {
			hue = 60F * (((b - r) / d) + 2F);
		} else /* if (max == blue) */ {
			hue = 60F * (((r - g) / d) + 4F);
		}
		if(hue < 0d) {
			hue += 360d;
		}
		
		final float saturation;
		if(max == 0) {
			saturation = 0F;
		} else {
			saturation = (float)delta / (float)max;
		}

		final float value = ((float)max) / 255F;

		return new float [] {hue, saturation, value}  ;
	}
}
